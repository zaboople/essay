# Elitism

If you already have a turing-complete toolset, any enhancement I propose is only valid on the principle that it makes the job [*easier*](./FiveKindsOfEasyAndHard.md), not harder. If you've made a good faith effort to learn to use my enhancement, but you're struggling just to understand it, I've probably failed.

Elitism tries to do the opposite, to deliberately obfuscate and overcomplicate computer programming. The goal is to stake out a claim to some pseudo-advanced intellectual territory that can be used to delineate Those Who Get It from Those Who Don't, so that one can seek membership in a group that is highly compensated and celebrated for its rare brilliance. Unfortunately this practice is much more commonplace than one would expect from a community that prides itself on pure objectivity and scientific thinking.

Of course we should not undervalue the achievements of truly competent programmers here, or sabotage experimentation and innovation. It takes time to get a good idea right. It takes time to learn to use it and make that time investment worthwhile. People look for excuses to protect the status quo because change is scary, and we should work to overcome those excuses, because innovation must violate the status quo.

In fact elitism undermines experimentation and innovation by redefining them on its own terms and inviting the eventual scorn of pragmatism-minded programmers who don't understand that the original intention was to work towards the same pragmatism they embrace. Most innovators are trying really hard to come up with an easier, better way; sometimes they fail, and sometimes their success is misunderstood.

Elitists are usually ultra-dogmatic, since there isn't any rational justification for what they are doing, although a lot of well-meaning software engineers fall into similar habits, doing it the way we do it because the way we do it is the way it is supposed to be done. Dogma is always counterproductive in its own right.

An elitist generally cannot tell the difference between good technology and failed technology. Their only criteria is "What makes me look smart," so the question is: Is it already more than trouble than it's worth, or do I need to repeatedly abuse it until it appears that way?

It would be nice if you could just say, "Whatever that guy does, we should do the opposite!" Unfortunately it's a little harder than that. When I look at programming tools like Python, Go & PHP, I'm kind of dissapointed by the difference between the good intentions the road was paved with, versus where it leads. Still, a truly pragmatic culture of programming is so important that I'm forced to admit that sometimes (dare we say... often?) you're better off with regressive rather than progressive tooling.

Back when Linus Torvalds was able to get away with saying things he can't get away with anymore, he would explain that he favored C over C++ not just on technical terms, but also to avoid programmers who had the wrong priorities. It's hard to be a pretentious snob when writing C. Some people would describe Torvalds as "genius", but he would likely prefer the designation of *pragmatist*: Working software always wins. At least a large portion of Torvalds' success owes to his ability to balance and prioritize practical usefulness over idealism, perfectionism, purity, and yes: elitism. But call that "genius" if you like; it's certainly rare enough.

In the end, leadership counts for a heck of a lot more than you'd think; when an innovator is too bashful, busy or otherwise to nurture or kill their own creations, elitists threaten to announce and anoint themselves as leaders, teaching everyone else to follow in their nonsensical footsteps. Perhaps we need to get over our collective obsession with high-IQ "genius", separate great leadership from great innovation, and teach leadership as an essential technical skill in its own right; because without it, we are doomed to regress over and over, in backlash to the pseudo-brilliance of elitism.

----

[Back to Software main page](./README.md)
